# Planet from Orbit

## Problem

When the camera is on the planet surface, the cubesphere-voxel system renders detailed chunk meshes. But when the camera pulls back to orbit -- tens of thousands of kilometers away -- individual voxels are far smaller than a pixel. Rendering millions of voxel faces at orbital distance is both wasteful and visually incorrect: aliasing artifacts dominate, and the geometry does not read as a planet. The engine needs a completely different rendering path for the orbital view: a smooth geometric sphere mesh textured with terrain colors derived from the heightmap and biome data. The atmosphere from story 04 should appear as a thin luminous glow around the planet's edge (the limb). The planet must be recognizable from orbit, with continents, oceans, and ice caps visible as color patterns on the sphere surface. This orbital representation works in concert with the LOD system (Epic 10) which triggers the switch between surface voxels and the orbital sphere.

## Solution

### Orbital Sphere Mesh Generation

Generate an icosphere mesh with enough subdivisions to appear smooth at typical orbital camera distances. The base icosphere is subdivided 5-6 times, producing ~40,000-~160,000 triangles -- enough for a smooth sphere that is cheap compared to voxel rendering:

```rust
use glam::Vec3;

/// Generate an icosphere mesh with the given number of subdivisions.
///
/// Returns (vertices, indices). Each vertex has a position on the unit sphere
/// and a UV coordinate for texture mapping.
pub fn generate_orbital_sphere(subdivisions: u32) -> OrbitalMesh {
    let mut mesh = create_icosahedron();
    for _ in 0..subdivisions {
        mesh = subdivide(&mesh);
    }
    // Normalize all vertices to the unit sphere.
    for v in &mut mesh.positions {
        *v = v.normalize();
    }
    // Compute UVs from spherical coordinates.
    for (i, pos) in mesh.positions.iter().enumerate() {
        let u = 0.5 + pos.z.atan2(pos.x) / std::f32::consts::TAU;
        let v = 0.5 - pos.y.asin() / std::f32::consts::PI;
        mesh.uvs[i] = [u, v];
    }
    mesh
}

pub struct OrbitalMesh {
    pub positions: Vec<Vec3>,
    pub uvs: Vec<[f32; 2]>,
    pub indices: Vec<u32>,
}
```

### Terrain Color Texture

A texture is generated by sampling the terrain heightmap and biome system at low resolution across the entire planet surface. Each texel represents a large area of terrain and is colored based on the dominant biome and elevation:

```rust
/// Generate a 2D equirectangular texture representing the planet's terrain colors.
///
/// Resolution is typically 2048x1024 (longitude x latitude).
pub fn generate_terrain_color_texture(
    terrain: &TerrainGenerator,
    biome_map: &BiomeMap,
    width: u32,
    height: u32,
    planet_radius: f64,
) -> Vec<[u8; 4]> {
    let mut pixels = Vec::with_capacity((width * height) as usize);

    for y in 0..height {
        let latitude = std::f64::consts::PI * (0.5 - y as f64 / height as f64);
        for x in 0..width {
            let longitude = std::f64::consts::TAU * (x as f64 / width as f64 - 0.5);

            // Convert lat/lon to a 3D sphere point.
            let sphere_point = glam::DVec3::new(
                latitude.cos() * longitude.cos(),
                latitude.sin(),
                latitude.cos() * longitude.sin(),
            );

            let height_val = terrain.sample_3d(sphere_point);
            let biome = biome_map.classify(latitude, height_val);
            let color = biome.color_at_elevation(height_val);

            pixels.push([
                (color.x * 255.0) as u8,
                (color.y * 255.0) as u8,
                (color.z * 255.0) as u8,
                255,
            ]);
        }
    }

    pixels
}
```

### Heightmap Texture for Relief

A separate heightmap texture stores normalized elevation values. The orbital shader uses this for subtle vertex displacement (giving mountains visible relief on the sphere) and for computing normal maps for orbital-scale lighting:

```rust
pub fn generate_heightmap_texture(
    terrain: &TerrainGenerator,
    width: u32,
    height: u32,
    max_elevation: f64,
) -> Vec<u16> {
    let mut pixels = Vec::with_capacity((width * height) as usize);

    for y in 0..height {
        let lat = std::f64::consts::PI * (0.5 - y as f64 / height as f64);
        for x in 0..width {
            let lon = std::f64::consts::TAU * (x as f64 / width as f64 - 0.5);
            let sphere_point = glam::DVec3::new(
                lat.cos() * lon.cos(),
                lat.sin(),
                lat.cos() * lon.sin(),
            );
            let h = terrain.sample_3d(sphere_point);
            let normalized = ((h / max_elevation) * 0.5 + 0.5).clamp(0.0, 1.0);
            pixels.push((normalized * 65535.0) as u16);
        }
    }

    pixels
}
```

### Orbital Render Pipeline

The orbital sphere uses a dedicated shader that samples the terrain color texture and applies basic directional lighting:

```wgsl
@group(0) @binding(0) var<uniform> camera: CameraUniform;
@group(1) @binding(0) var terrain_texture: texture_2d<f32>;
@group(1) @binding(1) var terrain_sampler: sampler;
@group(1) @binding(2) var<uniform> planet: PlanetUniform;

struct PlanetUniform {
    model: mat4x4<f32>,
    sun_direction: vec3<f32>,
    planet_radius: f32,
};

@vertex
fn vs_orbital(in: OrbitalVertexInput) -> OrbitalVertexOutput {
    var out: OrbitalVertexOutput;
    let world_pos = planet.model * vec4<f32>(in.position * planet.planet_radius, 1.0);
    out.clip_position = camera.view_proj * world_pos;
    out.uv = in.uv;
    out.world_normal = normalize((planet.model * vec4<f32>(in.position, 0.0)).xyz);
    out.world_position = world_pos.xyz;
    return out;
}

@fragment
fn fs_orbital(in: OrbitalVertexOutput) -> @location(0) vec4<f32> {
    let terrain_color = textureSample(terrain_texture, terrain_sampler, in.uv).rgb;

    // Simple Lambert diffuse lighting.
    let ndotl = max(dot(in.world_normal, planet.sun_direction), 0.0);
    let ambient = vec3<f32>(0.05);
    let lit_color = terrain_color * (ambient + ndotl * vec3<f32>(1.0));

    return vec4<f32>(lit_color, 1.0);
}
```

### Atmosphere Limb Glow

From orbit, the atmosphere is visible as a thin glow around the planet's silhouette. The atmosphere shader (story 04) already handles this case: view rays that pass through the atmosphere but miss the planet surface accumulate scattering, producing the limb glow. The orbital render order is:

1. Render the orbital sphere mesh (opaque terrain).
2. Render the atmosphere post-pass (which reads depth to blend correctly).

The atmosphere automatically produces the limb glow because rays near the planet edge have long paths through the atmosphere.

### Planet Rotation

The orbital sphere rotates to show the planet's spin. The model matrix includes a Y-axis rotation based on the in-game time:

```rust
pub fn orbital_model_matrix(
    planet_center: Vec3,
    planet_radius: f32,
    rotation_angle: f32,
) -> Mat4 {
    Mat4::from_translation(planet_center)
        * Mat4::from_rotation_y(rotation_angle)
        * Mat4::from_scale(Vec3::splat(planet_radius))
}
```

## Outcome

The `nebula-planet` crate exports `OrbitalRenderer`, `generate_orbital_sphere()`, `generate_terrain_color_texture()`, and `generate_heightmap_texture()`. When the camera is at orbital distance, the planet renders as a textured sphere with terrain colors, directional lighting, and an atmosphere limb glow. The planet rotates based on in-game time. Terrain colors (green forests, brown mountains, white ice caps, blue oceans) are recognizable from orbit. The sphere mesh is generated once and reused; the terrain color texture is generated at planet creation and updated only if terrain changes.

## Demo Integration

**Demo crate:** `nebula-demo`

From orbit, the planet renders as a textured sphere with visible continents, oceans, and ice caps. The atmosphere glows at the limb. The planet rotates slowly.

## Crates & Dependencies

| Crate | Version | Purpose |
|-------|---------|---------|
| `wgpu` | `24.0` | Render pipeline, texture creation, draw calls |
| `glam` | `0.29` | Matrix math, sphere generation, spherical coordinates |
| `bytemuck` | `1.21` | Uniform buffer serialization |

Internal dependencies: `nebula-render`, `nebula-terrain`, `nebula-cubesphere`, `nebula-planet` (atmosphere). Rust edition 2024.

## Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use glam::Vec3;

    #[test]
    fn test_planet_visible_as_sphere_from_orbit() {
        let mesh = generate_orbital_sphere(5);

        // All vertices should be on the unit sphere.
        for pos in &mesh.positions {
            let len = pos.length();
            assert!(
                (len - 1.0).abs() < 1e-5,
                "Orbital sphere vertex not on unit sphere: length = {len}"
            );
        }

        // Should have a reasonable number of triangles for a smooth sphere.
        let triangle_count = mesh.indices.len() / 3;
        assert!(
            triangle_count > 10_000,
            "Expected >10k triangles for subdivision 5, got {triangle_count}"
        );
    }

    #[test]
    fn test_terrain_colors_are_recognizable() {
        let terrain = TerrainGenerator::with_seed(42);
        let biome_map = BiomeMap::default();
        let texture = generate_terrain_color_texture(&terrain, &biome_map, 256, 128, 6_371_000.0);

        assert_eq!(texture.len(), 256 * 128, "Texture size mismatch");

        // Verify that the texture contains variety (not all one color).
        let unique_colors: std::collections::HashSet<[u8; 4]> =
            texture.iter().copied().collect();
        assert!(
            unique_colors.len() > 100,
            "Terrain texture should have color variety, got {} unique colors",
            unique_colors.len()
        );

        // Verify no fully transparent pixels (alpha should always be 255).
        for (i, pixel) in texture.iter().enumerate() {
            assert_eq!(
                pixel[3], 255,
                "Pixel {i} has unexpected alpha: {}",
                pixel[3]
            );
        }
    }

    #[test]
    fn test_atmosphere_glow_visible_from_orbit() {
        let params = AtmosphereParams::earth_like(6_371_000.0);
        let camera_pos = Vec3::new(0.0, 0.0, params.planet_radius * 5.0); // 5 radii away
        let look_dir = Vec3::new(0.0, 0.0, -1.0); // Looking at planet

        // A ray that grazes the planet limb should pass through atmosphere.
        let limb_dir = Vec3::new(0.0, 1.0, -3.0).normalize(); // Slightly above center
        let (t_near, t_far) = ray_sphere_intersect_f32(
            camera_pos,
            limb_dir,
            Vec3::ZERO,
            params.atmosphere_radius,
        );

        let hits_planet = ray_sphere_intersect_f32(
            camera_pos,
            limb_dir,
            Vec3::ZERO,
            params.planet_radius,
        );

        assert!(
            t_far > t_near && t_near > 0.0,
            "Limb ray should hit atmosphere"
        );
        assert!(
            hits_planet.0 < 0.0 || hits_planet.1 < 0.0,
            "Limb ray should miss the planet surface (grazing)"
        );
    }

    #[test]
    fn test_planet_size_decreases_with_distance() {
        let planet_radius = 6_371_000.0_f32;
        let fov = 60.0_f32.to_radians();

        // Angular size at different distances.
        let distances = [
            planet_radius * 2.0,
            planet_radius * 5.0,
            planet_radius * 20.0,
        ];
        let mut prev_angular_size = f32::MAX;

        for &dist in &distances {
            let angular_size = 2.0 * (planet_radius / dist).asin();
            assert!(
                angular_size < prev_angular_size,
                "Planet should appear smaller at distance {dist}: \
                 angular_size={angular_size} >= prev={prev_angular_size}"
            );
            prev_angular_size = angular_size;
        }
    }

    #[test]
    fn test_rotation_is_visible() {
        let t0 = orbital_model_matrix(Vec3::ZERO, 1.0, 0.0);
        let t1 = orbital_model_matrix(Vec3::ZERO, 1.0, 0.5);
        let t2 = orbital_model_matrix(Vec3::ZERO, 1.0, 1.0);

        // The model matrices at different rotation angles should differ.
        assert_ne!(
            t0, t1,
            "Model matrix should change with rotation"
        );
        assert_ne!(
            t1, t2,
            "Model matrix should change with rotation"
        );

        // A point on the equator should move.
        let equator_point = glam::Vec4::new(1.0, 0.0, 0.0, 1.0);
        let p0 = t0 * equator_point;
        let p1 = t1 * equator_point;
        let diff = (p0 - p1).length();
        assert!(
            diff > 0.01,
            "Equator point should move with rotation, diff = {diff}"
        );
    }
}
```
