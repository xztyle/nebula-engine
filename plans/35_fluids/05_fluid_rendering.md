# Fluid Rendering

## Problem

Fluid in a voxel world looks nothing like solid blocks. Water is transparent, shimmers, distorts objects beneath the surface, gets darker with depth, and has a surface that moves. Lava glows and pulses. Oil is dark and reflective. The existing opaque voxel rendering pipeline cannot produce any of these effects. Without a dedicated fluid rendering system, fluids would either be invisible (if skipped by the mesher) or render as ugly solid-colored cubes indistinguishable from glass. The engine needs a separate render pass for fluids with alpha blending, vertex-animated surface waves, depth-dependent color tinting, Fresnel-based surface reflections, and below-surface distortion. Additionally, partial fill levels (a block that is 3/7 full) must render with a lowered top face, not a full-height cube, to visually communicate the fluid volume.

## Solution

### Fluid Mesh Generation

Fluid surfaces are generated by a specialized mesher that runs after the solid voxel mesher. For each chunk containing fluid, the fluid mesher emits quads for the visible faces of fluid cells:

```rust
/// Vertex format for fluid rendering.
#[repr(C)]
#[derive(Clone, Copy, Debug, bytemuck::Pod, bytemuck::Zeroable)]
pub struct FluidVertex {
    /// World-space position (relative to chunk origin, f32).
    pub position: [f32; 3],
    /// Normal vector for lighting.
    pub normal: [f32; 3],
    /// UV coordinates for wave animation.
    pub uv: [f32; 2],
    /// Fluid depth below the surface (0.0 at surface, increases with depth).
    /// Used for depth-based color tinting.
    pub depth: f32,
    /// Fluid type index (for selecting color/material in the shader).
    pub fluid_type: u32,
}
```

The top face of a fluid cell is positioned according to its fill level:

```rust
/// Returns the Y offset (0.0 to 1.0) of the fluid surface within a voxel.
/// Level 7 (full) = 1.0, level 1 = 1/7 = 0.143, level 0 = not rendered.
fn surface_height(level: u8) -> f32 {
    level as f32 / FluidState::FULL as f32
}
```

Face culling rules for fluid:
- **Top face**: Render if the cell above is not the same fluid at level 7 (full).
- **Bottom face**: Render if the cell below is air or a different material.
- **Side faces**: Render if the adjacent cell is air or a different material. If the adjacent cell is the same fluid at a lower level, render the exposed portion above the neighbor's surface height.
- **Solid-fluid interface**: Never render a fluid face against a solid voxel (the solid face is already rendered by the solid mesher). This prevents z-fighting.

### WGSL Shader

The fluid shader handles transparency, animation, depth tinting, Fresnel reflection, and below-surface distortion in a single pass:

```wgsl
struct CameraUniform {
    view_proj: mat4x4<f32>,
    camera_pos: vec3<f32>,
    time: f32,
};

struct FluidMaterial {
    base_color: vec4<f32>,     // RGBA with alpha for transparency
    deep_color: vec4<f32>,     // Color at maximum depth
    wave_amplitude: f32,       // Vertex displacement magnitude
    wave_frequency: f32,       // Spatial frequency of waves
    wave_speed: f32,           // Temporal frequency of waves
    emissive_strength: f32,    // 0 for water/oil, >0 for lava glow
    distortion_strength: f32,  // How much to distort below-surface objects
    fresnel_power: f32,        // Fresnel exponent (5.0 typical for water)
};

@group(0) @binding(0) var<uniform> camera: CameraUniform;
@group(1) @binding(0) var<uniform> material: FluidMaterial;
@group(1) @binding(1) var scene_depth_texture: texture_depth_2d;
@group(1) @binding(2) var scene_color_texture: texture_2d<f32>;
@group(1) @binding(3) var linear_sampler: sampler;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) depth: f32,
    @location(4) fluid_type: u32,
};

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) world_position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) depth: f32,
    @location(4) view_dir: vec3<f32>,
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var pos = in.position;

    // Animated surface waves (only on top faces, where normal points up)
    if in.normal.y > 0.5 {
        let wave1 = sin(pos.x * material.wave_frequency + camera.time * material.wave_speed);
        let wave2 = sin(pos.z * material.wave_frequency * 0.7 + camera.time * material.wave_speed * 1.3);
        pos.y += (wave1 + wave2) * 0.5 * material.wave_amplitude;
    }

    var out: VertexOutput;
    out.clip_position = camera.view_proj * vec4<f32>(pos, 1.0);
    out.world_position = pos;
    out.normal = in.normal;
    out.uv = in.uv;
    out.depth = in.depth;
    out.view_dir = normalize(camera.camera_pos - pos);
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    // Depth-based color tinting: lerp from base_color to deep_color
    let depth_factor = clamp(in.depth / 16.0, 0.0, 1.0);
    var color = mix(material.base_color, material.deep_color, depth_factor);

    // Fresnel reflection: more reflective at glancing angles
    let n_dot_v = max(dot(in.normal, in.view_dir), 0.0);
    let fresnel = pow(1.0 - n_dot_v, material.fresnel_power);
    let sky_color = vec4<f32>(0.6, 0.8, 1.0, 1.0); // Simplified sky reflection
    color = mix(color, sky_color, fresnel * 0.5);

    // Emissive (lava glow)
    let emissive = material.base_color.rgb * material.emissive_strength;
    color = vec4<f32>(color.rgb + emissive, color.a);

    return color;
}
```

### Render Pass Configuration

Fluid rendering uses a dedicated render pass that runs **after** the opaque geometry pass:

1. **Opaque pass** renders all solid voxels to the color buffer and depth buffer.
2. **Fluid pass** renders fluid meshes with alpha blending enabled, reading (but not clearing) the existing depth buffer.

Alpha blending configuration:

```rust
let fluid_blend_state = wgpu::BlendState {
    color: wgpu::BlendComponent {
        src_factor: wgpu::BlendFactor::SrcAlpha,
        dst_factor: wgpu::BlendFactor::OneMinusSrcAlpha,
        operation: wgpu::BlendOperation::Add,
    },
    alpha: wgpu::BlendComponent {
        src_factor: wgpu::BlendFactor::One,
        dst_factor: wgpu::BlendFactor::OneMinusSrcAlpha,
        operation: wgpu::BlendOperation::Add,
    },
};
```

The fluid pass writes to the color buffer but uses `depth_write_enabled: false` with `CompareFunction::GreaterEqual` (reverse-Z) for depth testing. This ensures fluid is correctly occluded by solid geometry in front of it but does not occlude other fluid surfaces behind it (allowing see-through transparency).

### Z-Fighting Prevention

Fluid surfaces that share a plane with solid voxel faces would z-fight. This is prevented by:
1. The fluid mesher never emitting faces that abut solid voxels (the solid face is sufficient).
2. For partial-level surfaces, the top face is inset by `surface_height(level)`, which is always below 1.0 for non-full cells.
3. A small depth bias (`depthBias: 1, depthBiasSlopeScale: 1.0`) in the pipeline's `DepthStencilState` for edge cases.

### Lava Rendering

Lava uses the same shader but with different material parameters:
- `emissive_strength: 3.0` produces a bright glow.
- `wave_amplitude: 0.02` creates a subtle roiling surface.
- `wave_speed: 0.3` for slow, viscous movement.
- `base_color: (1.0, 0.3, 0.0, 0.95)` for near-opaque orange.
- `distortion_strength: 0.05` for heat-shimmer distortion.

### Pipeline Struct

```rust
pub struct FluidPipeline {
    pub pipeline: wgpu::RenderPipeline,
    pub camera_bind_group_layout: wgpu::BindGroupLayout,
    pub material_bind_group_layout: wgpu::BindGroupLayout,
}

impl FluidPipeline {
    pub fn new(
        device: &wgpu::Device,
        shader: &wgpu::ShaderModule,
        surface_format: wgpu::TextureFormat,
        depth_format: wgpu::TextureFormat,
    ) -> Self { ... }
}
```

## Outcome

The `nebula-rendering` crate exports `FluidVertex`, `FluidPipeline`, fluid mesh generation functions, and WGSL shader source for fluid rendering. Water is semi-transparent with animated waves, depth tinting, and Fresnel reflections. Lava glows with emissive lighting. Partial fill levels render with lowered top faces. No z-fighting occurs between fluid and solid surfaces. Running `cargo test -p nebula-rendering` passes all fluid rendering tests. Rust edition 2024.

## Demo Integration

**Demo crate:** `nebula-demo`

Water voxels are rendered with translucent blue surfaces and a subtle ripple animation. The player can see through shallow water to the terrain below.

## Crates & Dependencies

| Crate | Version | Purpose |
|-------|---------|---------|
| `wgpu` | `28.0` | GPU render pipeline, shaders, blend state, and texture sampling |
| `bytemuck` | `1.21` | Pod/Zeroable derives for vertex and uniform structs |
| `glam` | `0.32` | Vector math for mesh generation and camera transforms |
| `bevy_ecs` | `0.18` | ECS integration for fluid render system scheduling |

Depends on Epic 04 (rendering infrastructure), Epic 07 (mesh generation patterns), and story 01 of this epic (`FluidState` for level-based surface height).

## Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_water_is_transparent() {
        let water_material = FluidMaterial {
            base_color: [0.2, 0.4, 0.9, 0.6],
            deep_color: [0.05, 0.1, 0.3, 0.9],
            wave_amplitude: 0.04,
            wave_frequency: 2.0,
            wave_speed: 1.5,
            emissive_strength: 0.0,
            distortion_strength: 0.02,
            fresnel_power: 5.0,
        };
        assert!(
            water_material.base_color[3] < 1.0,
            "Water must have alpha < 1.0 for transparency"
        );
        assert!(
            water_material.base_color[3] > 0.0,
            "Water must have alpha > 0.0 to be visible"
        );
    }

    #[test]
    fn test_surface_animates_over_time() {
        // Verify that the wave function produces different heights at different times
        let freq = 2.0_f32;
        let speed = 1.5_f32;
        let x = 5.0_f32;

        let height_t0 = (x * freq + 0.0 * speed).sin();
        let height_t1 = (x * freq + 1.0 * speed).sin();
        let height_t2 = (x * freq + 2.0 * speed).sin();

        assert!(
            (height_t0 - height_t1).abs() > 0.001 || (height_t1 - height_t2).abs() > 0.001,
            "Wave height must change over time"
        );
    }

    #[test]
    fn test_deeper_water_is_darker() {
        let base_color = [0.2_f32, 0.4, 0.9, 0.6];
        let deep_color = [0.05_f32, 0.1, 0.3, 0.9];

        // At depth 0, color should equal base_color
        let shallow_factor = (0.0_f32 / 16.0).clamp(0.0, 1.0);
        let shallow_r = base_color[0] * (1.0 - shallow_factor) + deep_color[0] * shallow_factor;

        // At depth 16, color should equal deep_color
        let deep_factor = (16.0_f32 / 16.0).clamp(0.0, 1.0);
        let deep_r = base_color[0] * (1.0 - deep_factor) + deep_color[0] * deep_factor;

        assert!(
            deep_r < shallow_r,
            "Deeper water should be darker: shallow_r={shallow_r}, deep_r={deep_r}"
        );
    }

    #[test]
    fn test_partial_level_has_lower_surface() {
        assert_eq!(surface_height(7), 1.0, "Full level should have surface at 1.0");
        assert_eq!(surface_height(0), 0.0, "Empty level should have surface at 0.0");

        for level in 1..7 {
            let h = surface_height(level);
            assert!(h > 0.0 && h < 1.0,
                "Partial level {level} should have surface between 0 and 1, got {h}");
        }

        // Monotonically increasing
        for level in 1..=7 {
            assert!(
                surface_height(level) > surface_height(level - 1),
                "Surface height must increase with level"
            );
        }
    }

    #[test]
    fn test_lava_glows() {
        let lava_material = FluidMaterial {
            base_color: [1.0, 0.3, 0.0, 0.95],
            deep_color: [0.8, 0.1, 0.0, 1.0],
            wave_amplitude: 0.02,
            wave_frequency: 1.0,
            wave_speed: 0.3,
            emissive_strength: 3.0,
            distortion_strength: 0.05,
            fresnel_power: 2.0,
        };
        assert!(
            lava_material.emissive_strength > 0.0,
            "Lava must have positive emissive strength for glow"
        );

        // Emissive contribution
        let emissive_r = lava_material.base_color[0] * lava_material.emissive_strength;
        assert!(emissive_r > 1.0, "Lava emissive should be HDR (>1.0)");
    }

    #[test]
    fn test_no_z_fighting_with_solid_voxels() {
        // Verify that the fluid mesher skips faces adjacent to solid voxels.
        // A fluid cell with a solid neighbor on the +X side should NOT emit a +X face.
        let solid_neighbors = [true, false, false, false, false, false]; // +X is solid
        let fluid_level = 7;

        let faces = compute_visible_fluid_faces(fluid_level, &solid_neighbors);

        assert!(
            !faces.contains(&Face::PosX),
            "Fluid face adjacent to solid voxel must not be emitted"
        );
        assert!(
            faces.contains(&Face::NegX),
            "Fluid face adjacent to air should be emitted"
        );
    }

    #[test]
    fn test_fluid_vertex_size() {
        // Verify vertex struct is correctly packed for GPU upload
        let expected_size = 3 * 4  // position: [f32; 3]
                         + 3 * 4  // normal: [f32; 3]
                         + 2 * 4  // uv: [f32; 2]
                         + 1 * 4  // depth: f32
                         + 1 * 4; // fluid_type: u32
        assert_eq!(
            std::mem::size_of::<FluidVertex>(),
            expected_size,
            "FluidVertex must be {expected_size} bytes for GPU layout"
        );
    }

    #[test]
    fn test_blend_state_is_alpha_blend() {
        let blend = fluid_blend_state();
        assert_eq!(blend.color.src_factor, wgpu::BlendFactor::SrcAlpha);
        assert_eq!(blend.color.dst_factor, wgpu::BlendFactor::OneMinusSrcAlpha);
        assert_eq!(blend.color.operation, wgpu::BlendOperation::Add);
    }
}
```
